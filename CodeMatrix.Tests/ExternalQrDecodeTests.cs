using Xunit;

namespace CodeGlyphX.Tests;

public sealed class ExternalQrDecodeTests {
    private const string Payload = "otpauth://totp/Example:alice@foo.com?secret=JBSWY3DPEHPK3PXP&issuer=Example&algorithm=SHA1&digits=6&period=30";

    // Generated with an external QR generator (Segno), not CodeGlyphX.
    private static readonly string[] Modules45 = {
        "111111100101111011111010011000101000101111111",
        "100000100010010111000110001111100101001000001",
        "101110100000111100101110100011011001001011101",
        "101110100000100101010101000001110001101011101",
        "101110100100011010001111111111111111101011101",
        "100000101111101111111000101100001100001000001",
        "111111101010101010101010101010101010101111111",
        "000000000100011001111000100000001001000000000",
        "100101101111101010001111100111000101010100000",
        "011100011000000001000010000000000100000000101",
        "111010101100001110101100110110001010100101001",
        "100111010110100100011001001101111100100010000",
        "101101100000000101111110101101111100011010010",
        "011010011101001111100000110101010010000001001",
        "011111101000011111111001110100011100111010010",
        "110111001011101101010010011010101100010010000",
        "010101100100000000101001001101001100010101010",
        "010010001011101100111011001011011000011001000",
        "100001100100011011111011110100111000010111011",
        "010001000011000001110011011001001011111100010",
        "100011111100111010101111101011010110111111001",
        "000110001110010011111000101000001000100010011",
        "001110101011100100111010111011100111101010101",
        "100110001100001001011000100110010010100011000",
        "100011111011011110101111101111111100111111010",
        "100101000001010010011101110010000010110010101",
        "010001110000101000101001001011011101000101010",
        "111101010001000101000010010101001100101010000",
        "110010101100110100011000011001011010001110000",
        "101001000000001011010010101100011000111000010",
        "011011110101101010111010101011011000111111011",
        "101001010110100000111000110100011000101110000",
        "010010111011000110010111000110110111011100010",
        "010100000001011010011100100010001000001001111",
        "000010110000001000011000010101000110001001101",
        "011110010010010101011001011000010101000001010",
        "100110110010110001111111111111011000111111011",
        "000000001101011001011000100000010011100011001",
        "111111100011110000101010110110101001101011110",
        "100000101100010100001000100110111001100010011",
        "101110100101111111111111101100101001111110001",
        "101110101000111000100100011101011000100110010",
        "101110100000110100001110010000001000111111011",
        "100000100110101010101101010111011011110010000",
        "111111101111101011010110110011110110100111010",
    };

    // Generated with Segno (version 9, ECC Q, mask 6, byte mode, boost_error=False).
    private static readonly string[] Modules53_V9Q_M6 = {
        "11111110001111011100010010011110111010100110001111111",
        "10000010100100010110110110110111101110000011001000001",
        "10111010001100000111000001000100101111110001001011101",
        "10111010100000111100101000100001101111011110101011101",
        "10111010100000010000001011111001100110100010001011101",
        "10000010010001100000100010001110100101101110001000001",
        "11111110101010101010101010101010101010101010101111111",
        "00000000101001011000101110001111000100001100000000000",
        "01011110100101011100100011111100011010011100111011010",
        "11110101111000001011000100110110101011100111111001100",
        "10011111001101011000101111011101010011011001101011010",
        "01101101010000001001101011010011101100011011010101010",
        "10011010000010111010011100110110101010111011110010100",
        "10001000111010010101110001100110100101110110011011111",
        "10101110111001010101101100000101101010111011111110101",
        "01110101001110100000000101010101110001100111001101111",
        "01010010101110010011001100000101101010100011010011000",
        "01111001111011110011011000010000111110010011011010000",
        "00010010001110001101011000111111100010000000110011001",
        "00000000101111010010000001101011010010000100111010110",
        "10111011101000010000011000110110001101101110101111100",
        "01010100000000111000011000111010011001001110111101011",
        "01011111101010010001100010001011110000111011101111110",
        "10001000001100010011100101000010110001100111110100011",
        "00111111101111010011010011111001101110001101111110011",
        "01101000111010101111111010001101110101110111100010011",
        "01111010101011011100111010101001011011111000101011111",
        "11001000110111011101011110001001101001001010100011010",
        "00101111111101011100110111111100110010100011111110110",
        "11001100000110101000000111100111001101001110110011110",
        "01001111000010100110001011101011110011011010101000001",
        "01101101101001001100101011100001110001101111001010111",
        "00010011000111011010011000101010110111101011001000100",
        "00011001001011011001001000010000011011111110101110010",
        "10101110010110001000101001000101011000000100000010100",
        "00000100010010010001010010100100100010000011011111010",
        "00111011011100100010010101100110101010001011011001011",
        "01101001000011110010010001010000010010101011001110010",
        "11101010010111101101010101000110010010010100011011101",
        "00001001000101010001110110110100001100110011010111110",
        "01110110011111100100111000001001110010110000111010010",
        "01101101110111011001001011101101001011001010001110100",
        "11011111110101000110011001000111111011010101001010101",
        "01100000001001111101111101011111011001100000001011111",
        "00010010010001100011100111111000010110000011111110100",
        "00000000110000011010000010001110010110100111100011101",
        "11111110010011101011001110101101110100001010101011100",
        "10000010100011001110010110001100011001100100100011010",
        "10111010111001101111100011111110111010101111111111000",
        "10111010111001001011001010111011010101110110100001001",
        "10111010001011111010110101011101100100110001011010001",
        "10000010110110000101111110000100001110101011111001101",
        "11111110010110011001010101100011110111100000111011000",
    };

    [Fact]
    public void DecodeModules_ExternalGeneratorQr_Succeeds() {
        var modules = ParseModules(Modules45);
        Assert.True(QrDecoder.TryDecode(modules, out var decoded));
        Assert.Equal(Payload, decoded.Text);
        Assert.Equal(7, decoded.Version);
    }

    [Fact]
    public void DecodeModules_ExternalGeneratorQr_Version9_Q_Mask6_Succeeds() {
        var modules = ParseModules(Modules53_V9Q_M6);
        Assert.True(QrDecoder.TryDecode(modules, out var decoded));
        Assert.Equal(Payload, decoded.Text);
        Assert.Equal(9, decoded.Version);
        Assert.Equal(QrErrorCorrectionLevel.Q, decoded.ErrorCorrectionLevel);
        Assert.Equal(6, decoded.Mask);
    }

    [Fact(Skip = "Encoder output differs from external generator for this vector; decoding external modules is the compatibility requirement.")]
    public void EncodeText_Version9_Q_Mask6_MatchesExternalModules() {
        var expected = ParseModules(Modules53_V9Q_M6);
        var qr = QrCodeEncoder.EncodeText(Payload, QrErrorCorrectionLevel.Q, minVersion: 9, maxVersion: 9, forceMask: 6);
        Assert.Equal(9, qr.Version);
        AssertBitMatrixEqual(expected, qr.Modules);
    }

    private static BitMatrix ParseModules(string[] rows) {
        var size = rows.Length;
        var matrix = new BitMatrix(size, size);

        for (var y = 0; y < size; y++) {
            var row = rows[y];
            Assert.Equal(size, row.Length);
            for (var x = 0; x < size; x++) {
                var c = row[x];
                matrix[x, y] = c == '1';
            }
        }

        return matrix;
    }

    private static void AssertBitMatrixEqual(BitMatrix expected, BitMatrix actual) {
        Assert.Equal(expected.Width, actual.Width);
        Assert.Equal(expected.Height, actual.Height);

        for (var y = 0; y < expected.Height; y++) {
            for (var x = 0; x < expected.Width; x++) {
                if (expected[x, y] == actual[x, y]) continue;
                Assert.Fail($"Mismatch at ({x},{y}).");
            }
        }
    }
}
